// File generated by script/ast.scm

#ifndef LOX_Stmt_H_
#define LOX_Stmt_H_

#include <scanner/Token.h>

namespace Lox {

class BlockStmt;
class ClassStmt;
class ExpressionStmt;
class FunctionStmt;
class IfStmt;
class PrintStmt;
class ReturnStmt;
class VarStmt;
class WhileStmt;


class Stmt {
public:
    class Visitor {
    public:
        virtual void visitBlockStmt(BlockStmt&) = 0;
        virtual void visitClassStmt(ClassStmt&) = 0;
        virtual void visitExpressionStmt(ExpressionStmt&) = 0;
        virtual void visitFunctionStmt(FunctionStmt&) = 0;
        virtual void visitIfStmt(IfStmt&) = 0;
        virtual void visitPrintStmt(PrintStmt&) = 0;
        virtual void visitReturnStmt(ReturnStmt&) = 0;
        virtual void visitVarStmt(VarStmt&) = 0;
        virtual void visitWhileStmt(WhileStmt&) = 0;
    };
    virtual void accept(Visitor &) = 0;
};

class BlockStmt : public Stmt {
public:
    BlockStmt() = default;

    ~BlockStmt() {}

    BlockStmt(std::vector<std::shared_ptr<Stmt>> statements)
    {
        statements_ = statements;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitBlockStmt(*this);
    }

    std::vector<std::shared_ptr<Stmt>> statements() const
    {
        return statements_;
    }
private:
    std::vector<std::shared_ptr<Stmt>> statements_;
};

class ClassStmt : public Stmt {
public:
    ClassStmt() = default;

    ~ClassStmt() {}

    ClassStmt(std::shared_ptr<Token> name, std::shared_ptr<VariableExpr> superclass, std::vector<std::shared_ptr<FunctionStmt>> methods)
    {
        name_ = name;
        superclass_ = superclass;
        methods_ = methods;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitClassStmt(*this);
    }

    std::shared_ptr<Token> name() const
    {
        return name_;
    }
    std::shared_ptr<VariableExpr> superclass() const
    {
        return superclass_;
    }
    std::vector<std::shared_ptr<FunctionStmt>> methods() const
    {
        return methods_;
    }
private:
    std::shared_ptr<Token> name_;
    std::shared_ptr<VariableExpr> superclass_;
    std::vector<std::shared_ptr<FunctionStmt>> methods_;
};

class ExpressionStmt : public Stmt {
public:
    ExpressionStmt() = default;

    ~ExpressionStmt() {}

    ExpressionStmt(std::shared_ptr<Expr> expression)
    {
        expression_ = expression;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitExpressionStmt(*this);
    }

    std::shared_ptr<Expr> expression() const
    {
        return expression_;
    }
private:
    std::shared_ptr<Expr> expression_;
};

class FunctionStmt : public Stmt {
public:
    FunctionStmt() = default;

    ~FunctionStmt() {}

    FunctionStmt(std::shared_ptr<Token> name, std::vector<std::shared_ptr<Token>> params, std::vector<std::shared_ptr<Stmt>> body)
    {
        name_ = name;
        params_ = params;
        body_ = body;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitFunctionStmt(*this);
    }

    std::shared_ptr<Token> name() const
    {
        return name_;
    }
    std::vector<std::shared_ptr<Token>> params() const
    {
        return params_;
    }
    std::vector<std::shared_ptr<Stmt>> body() const
    {
        return body_;
    }
private:
    std::shared_ptr<Token> name_;
    std::vector<std::shared_ptr<Token>> params_;
    std::vector<std::shared_ptr<Stmt>> body_;
};

class IfStmt : public Stmt {
public:
    IfStmt() = default;

    ~IfStmt() {}

    IfStmt(std::shared_ptr<Expr> condition, std::shared_ptr<Stmt> thenbranch, std::shared_ptr<Stmt> elsebranch)
    {
        condition_ = condition;
        thenbranch_ = thenbranch;
        elsebranch_ = elsebranch;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitIfStmt(*this);
    }

    std::shared_ptr<Expr> condition() const
    {
        return condition_;
    }
    std::shared_ptr<Stmt> thenbranch() const
    {
        return thenbranch_;
    }
    std::shared_ptr<Stmt> elsebranch() const
    {
        return elsebranch_;
    }
private:
    std::shared_ptr<Expr> condition_;
    std::shared_ptr<Stmt> thenbranch_;
    std::shared_ptr<Stmt> elsebranch_;
};

class PrintStmt : public Stmt {
public:
    PrintStmt() = default;

    ~PrintStmt() {}

    PrintStmt(std::shared_ptr<Expr> expression)
    {
        expression_ = expression;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitPrintStmt(*this);
    }

    std::shared_ptr<Expr> expression() const
    {
        return expression_;
    }
private:
    std::shared_ptr<Expr> expression_;
};

class ReturnStmt : public Stmt {
public:
    ReturnStmt() = default;

    ~ReturnStmt() {}

    ReturnStmt(std::shared_ptr<Token> keyword, std::shared_ptr<Expr> value)
    {
        keyword_ = keyword;
        value_ = value;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitReturnStmt(*this);
    }

    std::shared_ptr<Token> keyword() const
    {
        return keyword_;
    }
    std::shared_ptr<Expr> value() const
    {
        return value_;
    }
private:
    std::shared_ptr<Token> keyword_;
    std::shared_ptr<Expr> value_;
};

class VarStmt : public Stmt {
public:
    VarStmt() = default;

    ~VarStmt() {}

    VarStmt(std::shared_ptr<Token> name, std::shared_ptr<Expr> initializer)
    {
        name_ = name;
        initializer_ = initializer;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitVarStmt(*this);
    }

    std::shared_ptr<Token> name() const
    {
        return name_;
    }
    std::shared_ptr<Expr> initializer() const
    {
        return initializer_;
    }
private:
    std::shared_ptr<Token> name_;
    std::shared_ptr<Expr> initializer_;
};

class WhileStmt : public Stmt {
public:
    WhileStmt() = default;

    ~WhileStmt() {}

    WhileStmt(std::shared_ptr<Expr> condition, std::shared_ptr<Stmt> body)
    {
        condition_ = condition;
        body_ = body;
    }
    void accept(Visitor &visitor) override
    {
        visitor.visitWhileStmt(*this);
    }

    std::shared_ptr<Expr> condition() const
    {
        return condition_;
    }
    std::shared_ptr<Stmt> body() const
    {
        return body_;
    }
private:
    std::shared_ptr<Expr> condition_;
    std::shared_ptr<Stmt> body_;
};

}

#endif
